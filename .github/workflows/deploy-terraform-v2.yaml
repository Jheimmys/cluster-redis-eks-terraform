name: Terraform - Create Resources

on:
  pull_request:
    branches: [ "master" ]
    paths:
      - 'backend-config/**'
      - 'infrastructure/**'
    types: [opened, synchronize, reopened]

  push:
    branches: [ "master" ]
    paths:
      - 'backend-config/**'
      - 'infrastructure/**'

jobs:
  check-commit:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'pull_request' &&
      (contains(github.event.pull_request.title, '#terraform') ||
       contains(github.event.pull_request.body, '#terraform'))
    steps:
      - run: echo "Pull Request válido para execução do Terraform workflow."

  backend-plan:
    if: github.event_name == 'pull_request'
    needs: check-commit
    runs-on: ubuntu-latest
    environment: terraform-plan
    env:
      BACKEND_DIR: "./backend-config"

    steps:
    - uses: actions/checkout@v4

    - uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.11.0

    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Terraform Init
      working-directory: ${{ env.BACKEND_DIR }}
      run: terraform init

    - name: Terraform Plan
      working-directory: ${{ env.BACKEND_DIR }}
      run: |
        terraform plan -no-color -lock=false > plan_output.txt
        echo "PLAN_OUTPUT<<EOF" >> $GITHUB_ENV
        cat plan_output.txt >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: Post Plan to PR
      uses: actions/github-script@v6
      env:
        PLAN_OUTPUT: ${{ env.PLAN_OUTPUT }}
      with:
        script: |
          const output = `### Terraform Plan (Backend)\n\n\`\`\`\n${process.env.PLAN_OUTPUT}\n\`\`\``;
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });

  infra-plan:
    if: github.event_name == 'pull_request'
    needs: [check-commit, backend-plan]
    runs-on: ubuntu-latest
    environment: terraform-plan
    env:
      INFRA_DIR: "./infrastructure"
      TF_STATE_BUCKET: "tfstate-cluster-redis-jheimmys"  # Ajustado para usar o bucket final

    steps:
    - uses: actions/checkout@v4

    - uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.11.0

    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Terraform Init
      working-directory: ${{ env.INFRA_DIR }}
      run: |
        terraform init \
          -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
          -backend-config="key=cluster-redis/terraform.tfstate" \
          -backend-config="region=${{ secrets.AWS_REGION }}" \
          -backend-config="skip_credentials_validation=true" \
          -backend-config="skip_region_validation=true"

    - name: Terraform Plan
      working-directory: ${{ env.INFRA_DIR }}
      run: |
        terraform plan -no-color -lock=false > plan_output.txt
        echo "INFRA_PLAN_OUTPUT<<EOF" >> $GITHUB_ENV
        cat plan_output.txt >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: Post Plan to PR
      uses: actions/github-script@v6
      env:
        PLAN_OUTPUT: ${{ env.INFRA_PLAN_OUTPUT }}
      with:
        script: |
          const output = `### Terraform Plan (Infra)\n\n\`\`\`\n${process.env.PLAN_OUTPUT}\n\`\`\``;
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });

  deploy-backend:
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    environment: deploy-backend
    env:
      BACKEND_DIR: "./backend-config"

    steps:
    - uses: actions/checkout@v4

    - uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.11.0

    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Ensure Backend Bucket Exists
      run: |
        if ! aws s3api head-bucket --bucket tfstate-cluster-redis-jheimmys 2>/dev/null; then
          aws s3api create-bucket --bucket tfstate-cluster-redis-jheimmys --region ${{ secrets.AWS_REGION }}
        else
          echo "Bucket existente. Nenhuma ação necessária."
        fi

    - name: Ensure DynamoDB Table Exists
      run: |
        if ! aws dynamodb describe-table --table-name terraform-lock 2>/dev/null; then
          aws dynamodb create-table \
            --table-name terraform-lock \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST
        else
          echo "Tabela DynamoDB existente. Nenhuma ação necessária."
        fi

    - name: Terraform Init
      working-directory: ${{ env.BACKEND_DIR }}
      run: terraform init

    - name: Terraform Apply (only if plan has changes)
      working-directory: ${{ env.BACKEND_DIR }}
      run: |
        PLAN_OUTPUT=$(terraform plan -detailed-exitcode -no-color -lock=false)
        EXIT_CODE=$?

        if [ $EXIT_CODE -eq 2 ]; then
          echo "Changes detected. Applying..."
          terraform apply -auto-approve
        elif [ $EXIT_CODE -eq 0 ]; then
          echo "No changes to apply."
        else
          echo "$PLAN_OUTPUT"
          echo "Error running terraform plan"
          exit $EXIT_CODE
        fi

    - name: Export Bucket Name
      working-directory: ${{ env.BACKEND_DIR }}
      run: echo "BUCKET_NAME=$(terraform output -raw s3_bucket_name)" >> $GITHUB_ENV

    - name: Set Output Variable
      working-directory: ${{ env.BACKEND_DIR }}
      id: backend_outputs
      run: echo "bucket_name=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT

    outputs:
      bucket_name: ${{ steps.backend_outputs.outputs.bucket_name }}

  deploy-infra:
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    needs: deploy-backend
    runs-on: ubuntu-latest
    environment: deploy-infra
    env:
      INFRA_DIR: "./infrastructure"

    steps:
    - uses: actions/checkout@v4

    - uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.11.0

    - uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Terraform Init (with real backend)
      working-directory: ${{ env.INFRA_DIR }}
      run: terraform init -backend-config="bucket=${{ needs.deploy-backend.outputs.bucket_name }}"  # Agora usando o bucket final

    - name: Terraform Apply
      working-directory: ${{ env.INFRA_DIR }}
      run: terraform apply -auto-approve

    - name: Configure EKS Access
      working-directory: ${{ env.INFRA_DIR }}
      run: |
        aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}
        kubectl get nodes
